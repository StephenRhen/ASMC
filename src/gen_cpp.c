/*
   gen_cpp.c - Generates c++ source code files. 

   Copyright (C) 2019 Stephen Rhen
 
   This file is part of asmc, A State Machine Compiler.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include "asmc.h"

void gen_cpp_hdr_file(state_machine_t *sm);
void gen_cpp_class_file(state_machine_t *sm);
void gen_run_method(state_machine_t *sm);
void gen_state_next(state_t *state);
void gen_transitions(transition_t *trans);
void gen_entry(state_t *state);
  

void gen_cpp(state_machine_t *sm)
{
  gen_cpp_hdr_file(sm);
  gen_cpp_class_file(sm);
}

void gen_cpp_hdr_file(state_machine_t *sm)
{
  char headerfile_name[strlen(sm->class_name) + 3];
  FILE *file;
  char *src, *dest;

  strcpy(headerfile_name, sm->class_name);
  strcat(headerfile_name, ".h");
  
  if (!(file = fopen(headerfile_name, "w"))) {
    fprintf(stderr, "Couldn't open file %s for writing\n",
	    headerfile_name);
    exit(EXIT_FAILURE);
  }

  fprintf(file,
	  "/* Code generated by asmc from file %s, do not edit. */\n\n",
	  sm->infile_basename);

  char wrapper[strlen(headerfile_name)+3];
  dest = wrapper;
  *dest++ = '_';
  for (src = headerfile_name; *src; src++) {
    if (*src == '.')
      *dest++ = '_';
    else
      *dest++ = toupper(*src);
  }
  *dest++ = '_';
  *dest = '\0';

  /* Standard header file preamble. */
  fprintf(file, "#ifndef %s\n#define %s\n\n", wrapper, wrapper);

  /* State machine class declaration. */
  fprintf(file, "class %s {\n  public:\n\n", sm->class_name);
  fprintf(file, "    // State machine events\n");
  fprintf(file, "    typedef enum {\n");
  for (event_t *event = sm->event_table; event; event = event->next) {
    fprintf(file, "      %s", event->name);
    if (event->next) {
      fputc(',', file);
    }
    fputc('\n', file);
  }
  fprintf(file, "    } event_t;\n\n");
  fprintf(file, "    // Return codes for run function.\n");
  fprintf(file, "    typedef enum {\n");
  fprintf(file, "      ok,\n      unknown_event,\n      unhandled_event\n");
  fprintf(file, "    } retstatus_t;\n\n");
  fprintf(file, "    %s();\n", sm->class_name);
  fprintf(file, "    void begin();\n");
  fprintf(file, "    retstatus_t run(event_t event);\n\n");
  fprintf(file, "  private:\n\n");
  fprintf(file, "    // Possiable states.\n");
  fprintf(file, "    typedef enum {\n");
  fprintf(file, "      nil = 0,\n");
  for (state_t *state = sm->state_table; state; state = state->next) {
    fprintf(file, "      %s,\n", state->name);
  }
  fprintf(file, "      error = -1\n");
  fprintf(file, "    } state_t;\n\n");
  fprintf(file, "    state_t state;\n");
  fprintf(file, "};\n\n");

  /* Standard header file post script */
  fprintf(file, "#endif /* %s */\n\n", wrapper);
  
  fclose(file);
  
}

void gen_cpp_class_file(state_machine_t *sm)
{
  char cppfile_name[strlen(sm->class_name) + 5];
  FILE *saved_stdout;
  char *src, *dest;
  state_t *state;
  transition_t *trans;

  strcpy(cppfile_name, sm->class_name);
  strcat(cppfile_name, ".cpp");

  fflush(stdout);
  saved_stdout = stdout;
  
  if (!(stdout = fopen(cppfile_name, "w"))) {
    fprintf(stderr, "Couldn't open file %s for writing\n",
	    cppfile_name);
    stdout = saved_stdout;
    exit(1);
  }

  printf("/* Code generated by asmc from file %s, do not edit. */\n\n",
	 sm->infile_basename);

  /* Include user code. */
  if (sm->first_code) {
    printf("%s\n\n", sm->first_code);
  }

  /* Include state machine header file. */
  printf("#include \"%s.h\"\n\n", sm->class_name);

  /* Constructor */
  printf("%s::%s()\n", sm->class_name, sm->class_name);
  printf("{\n");
  printf("  state = %s;\n", sm->start_state->name);
  printf("}\n\n");

  /* Initialization */
  printf("void %s::begin()\n{\n}\n\n", sm->class_name);

  /* The event processing code */
  gen_run_method(sm);
  
  /* end of the event processing code */
  
  fclose(stdout);
  stdout = saved_stdout;

}

/* Output code for the run method to handle events. */
void gen_run_method(state_machine_t *sm)
{
  state_t *state;
  transition_t *trans;
  
  printf("%s::retstatus_t %s::run(event_t event)\n{\n",
	 sm->class_name, sm->class_name);
  printf("  state_t next_state = error;\n\n");
  printf("  switch(state) {\n\n");

  for (state = sm->state_table; state; state = state->next) {
    printf("  case %s:\n\n", state->name);

    /* Determine next state */
    gen_state_next(state);

    printf("    if (next_state == error)\n");
    printf("      return unhandled_event;\n\n");

    /* Perform exit actions */
    if (state->exit) {
      printf("    /* Perform exit actions */\n");
      printf("    if (next_state != nil) {\n");
      printf("      %s\n", state->exit);
      printf("    }\n\n");
    }

    gen_transitions(state->trans_list);
 
    printf("    break;\n\n");
  }
  printf("  } /* switch (state) */\n\n");
  printf("  if (next_state) {\n");
  
  gen_entry(sm->state_table);
  
  printf("    state = next_state;\n");
  printf("  }\n\n");
  printf("  return ok;\n");
  printf("}\n\n");

}

/* Generate code to determine next state
 *
 *   TODO: Add default transitions
 *         Add guards
 *         Combine Common states
 */
void gen_state_next(state_t *state)
{
  printf("    /* Determine next state. */\n");
  printf("    switch (event) {\n");
  
  for (transition_t *trans = state->trans_list; trans; trans = trans->next) {
    printf("      case %s:\n", trans->event->name);
    if (!trans->next_state) {
      printf("        next_state = nil;\n");
    }
    else {
      printf("        next_state = %s;\n", trans->next_state->name);
    }
    printf("        break;\n");
  }
  printf("      default:\n");
  printf("        ; /* empty */\n");
  printf("    } /* switch (event) */\n\n");
}

void gen_transitions(transition_t *trans)
{

  /* Skip transitions with no actions */
  while (trans && !trans->code)
    trans = trans->next;

  if (trans) {
    printf("    /* Perform actions for the transition */\n");
    printf("    switch (event) {\n");

    while(trans) {
      if (trans->code) {
	printf("      case %s:\n", trans->event->name);
	printf("        %s\n", trans->code);
	printf("        break;\n");
      }
      trans = trans->next;
    }
    printf("      default:\n");
    printf("        ; /* empty */\n");
    printf("    } /* switch(event) */\n\n");
  } 
}

void gen_entry(state_t *state)
{

  /* Skip states with no entry actions */
  while (state && !state->entry)
    state = state->next;

  if (state) {
    printf("    /* Preform entry actions for the next state */\n");
    printf("    switch (next_state) {\n");

    while (state) {
      if (state->entry) {
	printf("      case %s:\n", state->name);
	printf("        %s\n", state->entry);
	printf("        break;\n");
      }
      state = state->next;
    }
    printf("      default:\n");
    printf("        ; /* empty */\n");
    printf("    } /* switch (next_state) */\n\n");
  }
}

