/*
   gen_cpp.c - Generates c++ source code files. 

   Copyright (C) 2019 Stephen Rhen
 
   This file is part of asmc, A State Machine Compiler.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include "asmc.h"

void gen_cpp_hdr_file(state_machine_t *sm);
void gen_cpp_class_file(state_machine_t *sm);
void gen_state_exit(state_t *state);
  


void gen_cpp(state_machine_t *sm)
{
  gen_cpp_hdr_file(sm);
  gen_cpp_class_file(sm);
}

void gen_cpp_hdr_file(state_machine_t *sm)
{
  char headerfile_name[strlen(sm->class_name) + 3];
  FILE *file;
  char *src, *dest;

  strcpy(headerfile_name, sm->class_name);
  strcat(headerfile_name, ".h");
  
  if (!(file = fopen(headerfile_name, "w"))) {
    fprintf(stderr, "Couldn't open file %s for writing\n",
	    headerfile_name);
    exit(EXIT_FAILURE);
  }

  fprintf(file,
	  "/* Code generated by asmc from file %s, do not edit. */\n\n",
	  sm->infile_basename);

  char wrapper[strlen(headerfile_name)+3];
  dest = wrapper;
  *dest++ = '_';
  for (src = headerfile_name; *src; src++) {
    if (*src == '.')
      *dest++ = '_';
    else
      *dest++ = toupper(*src);
  }
  *dest++ = '_';
  *dest = '\0';

  /* Standard header file preamble. */
  fprintf(file, "#ifndef %s\n#define %s\n\n", wrapper, wrapper);

  /* State machine class declaration. */
  fprintf(file, "class %s {\n  public:\n\n", sm->class_name);
  fprintf(file, "    // State machine events\n");
  fprintf(file, "    typedef enum {\n");
  for (event_t *event = sm->event_table; event; event = event->next) {
    fprintf(file, "      %s", event->name);
    if (event->next) {
      fputc(',', file);
    }
    fputc('\n', file);
  }
  fprintf(file, "    } event_t;\n\n");
  fprintf(file, "    // Return codes for run function.\n");
  fprintf(file, "    typedef enum {\n");
  fprintf(file, "      ok,\n      unknown_event,\n      unhandled_event\n");
  fprintf(file, "    } retstatus_t;\n\n");
  fprintf(file, "    %s();\n", sm->class_name);
  fprintf(file, "    void begin();\n");
  fprintf(file, "    retstatus_t run(event_t event);\n\n");
  fprintf(file, "  private:\n\n");
  fprintf(file, "    // Possiable states.\n");
  fprintf(file, "    typedef enum {\n");
  for (state_t *state = sm->state_table; state; state = state->next) {
    fprintf(file, "      %s", state->name);
    if (state->next) {
      fputc(',', file);
    }
    fputc('\n', file);
  }
  fprintf(file, "    } state_t;\n\n");
  fprintf(file, "    state_t state;\n");
  fprintf(file, "};\n\n");

  /* Standard header file post script */
  fprintf(file, "#endif /* %s */\n\n", wrapper);
  
  fclose(file);
  
}

void gen_cpp_class_file(state_machine_t *sm)
{
  char cppfile_name[strlen(sm->class_name) + 5];
  FILE *saved_stdout;
  char *src, *dest;
  state_t *state;
  transition_t *trans;

  strcpy(cppfile_name, sm->class_name);
  strcat(cppfile_name, ".cpp");

  fflush(stdout);
  saved_stdout = stdout;
  
  if (!(stdout = fopen(cppfile_name, "w"))) {
    fprintf(stderr, "Couldn't open file %s for writing\n",
	    cppfile_name);
    stdout = saved_stdout;
    exit(1);
  }

  printf("/* Code generated by asmc from file %s, do not edit. */\n\n",
	 sm->infile_basename);

  /* Include user code. */
  if (sm->first_code) {
    printf("%s\n\n", sm->first_code);
  }

  /* Include state machine header file. */
  printf("#include \"%s.h\"\n\n", sm->class_name);

  /* Constructor */
  printf("%s::%s()\n", sm->class_name, sm->class_name);
  printf("{\n");
  printf("  state = %s;\n", sm->start_state->name);
  printf("}\n\n");

  /* Initialization */
  printf("void %s::begin()\n{\n}\n\n", sm->class_name);

  /* The event processing code */
  printf("%s::retstatus_t %s::run(event_t event)\n{\n",
	 sm->class_name, sm->class_name);
  printf("  state_t next_state;\n");
  printf("  int handled = 0;\n\n");
  
  printf("  switch(state) {\n");

  for (state = sm->state_table; state; state = state->next) {
    printf("  case %s:\n\n", state->name);
    if (state->exit) {
      gen_state_exit(state);
    }
    for (trans = state->trans_list; trans; trans = trans->next) {
      printf("    if (event == %s) {\n", trans->event->name);
      printf("      handled = 1;\n");
      if (trans->next_state) {
	printf("      next_state = %s;\n", trans->next_state->name);
      }
      if (trans->code) {
	printf("%s\n", trans->code);
      }
      printf("    }\n");
      printf("    break;\n\n");
    }    
  }
  printf("  } /* switch */\n\n");
  printf("  if (!handled) {\n");
  printf("    return unhandled_event;\n");
  printf("  }\n\n");
  printf("  if (next_state) {\n");
  printf("    state = next_state;\n");
  printf("  }\n\n");
  printf("  return ok;\n");
  printf("}\n\n");
  
  /* end of the event processing code */
  
  fclose(stdout);
  stdout = saved_stdout;

}

void gen_state_exit(state_t *state)
{
  int found = 0;

  for (transition_t *trans = state->trans_list; trans; trans = trans->next) {
    if (trans->next_state) {
      if (!found) {
	found = 1;
	printf("    /* Perform state exit actions. */\n");
	printf("    if (");
      }
      else {
	printf(" ||\n        ");
      }
      printf("(event == %s)", trans->event->name);
    }
  }
  printf(") {\n");

  if (found) {
    printf("%s\n    }\n\n", state->exit);
  }
}
