/*
   gen_cpp.c - Generates c++ source code files. 

   Copyright (C) 2019 Stephen Rhen
 
   This file is part of asmc, A State Machine Compiler.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include "asmc.h"

void gen_cpp_hdr_file(state_machine_t *sm);
void gen_cpp_class_file(state_machine_t *sm);
void gen_run_method(FILE *file, state_machine_t *sm);
void gen_state_next(FILE *file, state_t *state);
void gen_transitions(FILE *file, transition_t *trans);
void gen_entry(FILE *file, state_t *state);
  

void gen_cpp(state_machine_t *sm)
{
  gen_cpp_hdr_file(sm);
  gen_cpp_class_file(sm);
}

void gen_cpp_hdr_file(state_machine_t *sm)
{
  char headerfile_name[strlen(sm->class_name) + 3];
  FILE *file;
  char *src, *dest;

  strcpy(headerfile_name, sm->class_name);
  strcat(headerfile_name, ".h");
  
  if (!(file = fopen(headerfile_name, "w"))) {
    fprintf(stderr, "Couldn't open file %s for writing\n",
	    headerfile_name);
    exit(EXIT_FAILURE);
  }

  fprintf(file,
	  "/* Code generated by asmc from file %s, do not edit. */\n\n",
	  sm->infile_basename);

  char wrapper[strlen(headerfile_name)+3];
  dest = wrapper;
  *dest++ = '_';
  for (src = headerfile_name; *src; src++) {
    if (*src == '.')
      *dest++ = '_';
    else
      *dest++ = toupper(*src);
  }
  *dest++ = '_';
  *dest = '\0';

  /* Standard header file preamble. */
  fprintf(file, "#ifndef %s\n#define %s\n\n", wrapper, wrapper);

  /* State machine class declaration. */
  fprintf(file, "class %s {\n  public:\n\n", sm->class_name);
  fprintf(file, "    // State machine events\n");
  fprintf(file, "    typedef enum {\n");
  for (event_t *event = sm->event_table; event; event = event->next) {
    fprintf(file, "      %s", event->name);
    if (event->next) {
      fputc(',', file);
    }
    fputc('\n', file);
  }
  fprintf(file, "    } event_t;\n\n");
  fprintf(file, "    // Return codes for run function.\n");
  fprintf(file, "    typedef enum {\n");
  fprintf(file, "      ok,\n      unknown_event,\n      unhandled_event\n");
  fprintf(file, "    } retstatus_t;\n\n");
  fprintf(file, "    %s();\n", sm->class_name);
  fprintf(file, "    void begin();\n");
  fprintf(file, "    retstatus_t run(event_t event, int data = 0);\n\n");
  fprintf(file, "  private:\n\n");
  fprintf(file, "    // Possiable states.\n");
  fprintf(file, "    typedef enum {\n");
  fprintf(file, "      nil = 0,\n");
  for (state_t *state = sm->state_table; state; state = state->next) {
    fprintf(file, "      %s,\n", state->name);
  }
  fprintf(file, "      error = -1\n");
  fprintf(file, "    } state_t;\n\n");
  fprintf(file, "    state_t state;\n");

  /* User supplied code. */
  if (sm->class_decl_code) {
    fprintf(file, "%s\n", sm->class_decl_code);
  }
  fprintf(file, "};\n\n");

  /* Standard header file post script */
  fprintf(file, "#endif /* %s */\n\n", wrapper);
  
  fclose(file);
  
}

void gen_cpp_class_file(state_machine_t *sm)
{
  char cppfile_name[strlen(sm->class_name) + 5];
  FILE *f;
  char *src, *dest;
  state_t *state;
  transition_t *trans;

  strcpy(cppfile_name, sm->class_name);
  strcat(cppfile_name, ".cpp");
  
  if (!(f = fopen(cppfile_name, "w"))) {
    fprintf(stderr, "Couldn't open file %s for writing\n",
	    cppfile_name);
    exit(1);
  }

  fprintf(f, "/* Code generated by asmc from file %s, do not edit. */\n\n",
	 sm->infile_basename);

  /* Include user code. */
  if (sm->hdr_code) {
    fprintf(f, "%s\n\n", sm->hdr_code);
  }

  /* Include state machine header file. */
  fprintf(f, "#include \"%s.h\"\n\n", sm->class_name);

  /* Constructor */
  fprintf(f, "%s::%s()\n", sm->class_name, sm->class_name);
  fprintf(f, "{\n");
  fprintf(f, "  state = %s;\n", sm->start_state->name);
  fprintf(f,"}\n\n");

  /* Initialization */
  fprintf(f, "void %s::begin()\n{\n}\n\n", sm->class_name);

  /* The event processing code */
  gen_run_method(f, sm);
  
  /* end of the event processing code */
  
  fclose(f);

}

/* Output code for the run method to handle events. */
void gen_run_method(FILE *f, state_machine_t *sm)
{
  state_t *state;
  transition_t *trans;
  
  fprintf(f, "%s::retstatus_t %s::run(event_t event, int data)\n{\n",
	  sm->class_name, sm->class_name);
  fprintf(f, "  state_t next_state = error;\n\n");
  fprintf(f, "  switch(state) {\n\n");

  for (state = sm->state_table; state; state = state->next) {
    fprintf(f, "  case %s:\n\n", state->name);

    /* Determine next state */
    gen_state_next(f, state);

    fprintf(f, "    if (next_state == error)\n");
    fprintf(f, "      return unhandled_event;\n\n");

    /* Perform exit actions */
    if (state->exit) {
      fprintf(f, "    /* Perform exit actions */\n");
      fprintf(f, "    if (next_state != nil) {\n");
      fprintf(f, "      %s\n", state->exit);
      fprintf(f, "    }\n\n");
    }

    gen_transitions(f, state->trans_list);
 
    fprintf(f, "    break;\n\n");
  }
  fprintf(f, "  } /* switch (state) */\n\n");
  fprintf(f, "  if (next_state) {\n");
  
  gen_entry(f, sm->state_table);
  
  fprintf(f, "    state = next_state;\n");
  fprintf(f, "  }\n\n");
  fprintf(f, "  return ok;\n");
  fprintf(f, "}\n\n");

}

/* Generate code to determine next state
 *
 *   TODO: Add default transitions
 *         Add guards
 *         Combine Common states
 */
void gen_state_next(FILE *f, state_t *state)
{
  event_t *prev_event = NULL;
  
  fprintf(f, "    /* Determine next state. */\n");
  fprintf(f, "    switch (event) {\n");
  
  for (transition_t *trans = state->trans_list; trans; trans = trans->next) {

    if (prev_event != trans->event) {
      if (prev_event)
	 fprintf(f, "        break;\n");
      fprintf(f, "      case %s:\n", trans->event->name);
    }
    fprintf(f, "        ");
    
    if (prev_event == trans->event)
      fprintf(f, "else ");

    if (trans->guard)
      fprintf(f, "if (%s) ", trans->guard);
    
    fprintf(f, "{\n");
    
    fprintf(f, "          next_state = ");
    if (!trans->next_state)
      fprintf(f, "nil;\n");
    else
      fprintf(f, "%s;\n", trans->next_state->name);

    fprintf(f, "        }\n");
   
    prev_event = trans->event;
  }
  fprintf(f, "      default:\n");
  fprintf(f, "        ; /* empty */\n");
  fprintf(f, "    } /* switch (event) */\n\n");
}

void gen_transitions(FILE *f, transition_t *trans)
{

  /* Skip transitions with no actions */
  while (trans && !trans->code)
    trans = trans->next;

  if (trans) {
    fprintf(f, "    /* Perform actions for the transition */\n");
    fprintf(f, "    switch (event) {\n");

    while(trans) {
      if (trans->code) {
	fprintf(f, "      case %s:\n", trans->event->name);
	fprintf(f, "        %s\n", trans->code);
	fprintf(f, "        break;\n");
      }
      trans = trans->next;
    }
    fprintf(f, "      default:\n");
    fprintf(f, "        ; /* empty */\n");
    fprintf(f, "    } /* switch(event) */\n\n");
  } 
}

void gen_entry(FILE *f, state_t *state)
{

  /* Skip states with no entry actions */
  while (state && !state->entry)
    state = state->next;

  if (state) {
    fprintf(f, "    /* Perform entry actions for the next state */\n");
    fprintf(f, "    switch (next_state) {\n");

    while (state) {
      if (state->entry) {
	fprintf(f, "      case %s:\n", state->name);
	fprintf(f, "        %s\n", state->entry);
	fprintf(f, "        break;\n");
      }
      state = state->next;
    }
    fprintf(f, "      default:\n");
    fprintf(f, "        ; /* empty */\n");
    fprintf(f, "    } /* switch (next_state) */\n\n");
  }
}

